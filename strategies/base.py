"""
Base strategy classes for the algorithmic trading system.
Provides abstract interfaces and common functionality for all trading strategies.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
from typing import Dict, List, Optional, Union, Any
import pandas as pd
import logging
from datetime import datetime

# Set up logging
logger = logging.getLogger(__name__)


class SignalType(Enum):
    """Types of trading signals."""

    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"
    CLOSE_LONG = "CLOSE_LONG"
    CLOSE_SHORT = "CLOSE_SHORT"


@dataclass
class StrategySignal:
    """
    Represents a trading signal generated by a strategy.
    """

    symbol: str
    signal_type: SignalType
    confidence: float  # 0.0 to 1.0
    price: Optional[float] = None
    quantity: Optional[int] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    timestamp: datetime = None
    strategy_name: str = ""
    metadata: Dict[str, Any] = None

    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now()
        if self.metadata is None:
            self.metadata = {}


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    Provides common interface and functionality for strategy implementation.
    """

    def __init__(self, name: str, symbols: List[str], **config):
        """
        Initialize the strategy.

        Args:
            name: Strategy name
            symbols: List of symbols to trade
            **config: Strategy-specific configuration parameters
        """
        self.name = name
        self.symbols = symbols
        self.config = config
        self.positions = {}  # Track current positions
        self.signals_history = []  # Track signal history
        self.performance_metrics = {}
        self.is_active = True

        # Default configuration
        self.default_config = {
            "max_position_size": 0.20,  # 20% of portfolio max per position
            "stop_loss_pct": 0.10,  # 10% stop loss
            "take_profit_pct": 0.20,  # 20% take profit
            "min_confidence": 0.7,  # Minimum signal confidence to trade
            "max_positions": 5,  # Maximum concurrent positions
            "risk_per_trade": 0.02,  # 2% portfolio risk per trade
        }

        # Merge with provided config
        self.config = {**self.default_config, **self.config}

        logger.info(f"Initialized {self.name} strategy for symbols: {self.symbols}")

    @abstractmethod
    def generate_signals(
        self, market_data: Dict[str, pd.DataFrame]
    ) -> List[StrategySignal]:
        """
        Generate trading signals based on market data.

        Args:
            market_data: Dictionary mapping symbol -> OHLCV DataFrame

        Returns:
            List of StrategySignal objects
        """
        pass

    @abstractmethod
    def should_enter_position(
        self, symbol: str, data: pd.DataFrame
    ) -> Optional[StrategySignal]:
        """
        Determine if strategy should enter a position for given symbol.

        Args:
            symbol: Stock/asset symbol
            data: OHLCV data for the symbol

        Returns:
            StrategySignal if should enter, None otherwise
        """
        pass

    @abstractmethod
    def should_exit_position(
        self, symbol: str, data: pd.DataFrame
    ) -> Optional[StrategySignal]:
        """
        Determine if strategy should exit existing position for given symbol.

        Args:
            symbol: Stock/asset symbol
            data: OHLCV data for the symbol

        Returns:
            StrategySignal if should exit, None otherwise
        """
        pass

    def validate_signal(self, signal: StrategySignal) -> bool:
        """
        Validate a trading signal against strategy rules.

        Args:
            signal: The signal to validate

        Returns:
            True if signal is valid, False otherwise
        """
        # Check confidence threshold
        if signal.confidence < self.config["min_confidence"]:
            logger.debug(
                f"Signal rejected: confidence {signal.confidence} below minimum {self.config['min_confidence']}"
            )
            return False

        # Check maximum positions limit
        if (
            signal.signal_type in [SignalType.BUY]
            and len(self.positions) >= self.config["max_positions"]
        ):
            logger.debug(
                f"Signal rejected: maximum positions limit {self.config['max_positions']} reached"
            )
            return False

        # Check if we already have a position in this symbol
        if signal.symbol in self.positions and signal.signal_type == SignalType.BUY:
            logger.debug(f"Signal rejected: already have position in {signal.symbol}")
            return False

        return True

    def calculate_position_size(
        self, signal: StrategySignal, portfolio_value: float, current_price: float
    ) -> int:
        """
        Calculate appropriate position size based on risk management rules.

        Args:
            signal: The trading signal
            portfolio_value: Current total portfolio value
            current_price: Current price of the asset

        Returns:
            Number of shares to trade
        """
        # Calculate maximum position value based on portfolio percentage
        max_position_value = portfolio_value * self.config["max_position_size"]

        # Calculate position size based on risk per trade
        risk_amount = portfolio_value * self.config["risk_per_trade"]

        # If we have stop loss, size based on stop loss distance
        if signal.stop_loss:
            stop_distance = abs(current_price - signal.stop_loss)
            risk_based_shares = int(risk_amount / stop_distance)
            max_shares = int(max_position_value / current_price)
            shares = min(risk_based_shares, max_shares)
        else:
            # Default to max position size
            shares = int(max_position_value / current_price)

        return max(1, shares)  # At least 1 share

    def update_position(
        self, symbol: str, signal: StrategySignal, executed_price: float, quantity: int
    ):
        """
        Update position tracking after signal execution.

        Args:
            symbol: Asset symbol
            signal: The executed signal
            executed_price: Price at which order was executed
            quantity: Quantity actually executed
        """
        if signal.signal_type == SignalType.BUY:
            self.positions[symbol] = {
                "quantity": quantity,
                "entry_price": executed_price,
                "entry_date": signal.timestamp,
                "stop_loss": signal.stop_loss,
                "take_profit": signal.take_profit,
                "strategy_signal": signal,
            }
            logger.info(
                f"Opened position: {symbol} x{quantity} @ ${executed_price:.2f}"
            )

        elif signal.signal_type in [SignalType.SELL, SignalType.CLOSE_LONG]:
            if symbol in self.positions:
                position = self.positions[symbol]
                profit_loss = (executed_price - position["entry_price"]) * quantity
                logger.info(
                    f"Closed position: {symbol} x{quantity} @ ${executed_price:.2f}, P&L: ${profit_loss:.2f}"
                )
                del self.positions[symbol]

    def get_current_positions(self) -> Dict[str, Any]:
        """Get current positions dictionary."""
        return self.positions.copy()

    def get_signals_history(self) -> List[StrategySignal]:
        """Get history of all generated signals."""
        return self.signals_history.copy()

    def add_signal_to_history(self, signal: StrategySignal):
        """Add a signal to the history."""
        self.signals_history.append(signal)

    def get_performance_summary(self) -> Dict[str, Any]:
        """
        Get basic performance metrics for the strategy.

        Returns:
            Dictionary with performance metrics
        """
        total_signals = len(self.signals_history)
        buy_signals = len(
            [s for s in self.signals_history if s.signal_type == SignalType.BUY]
        )
        sell_signals = len(
            [
                s
                for s in self.signals_history
                if s.signal_type in [SignalType.SELL, SignalType.CLOSE_LONG]
            ]
        )

        return {
            "strategy_name": self.name,
            "total_signals": total_signals,
            "buy_signals": buy_signals,
            "sell_signals": sell_signals,
            "current_positions": len(self.positions),
            "active_symbols": self.symbols,
            "is_active": self.is_active,
            "last_signal_time": (
                self.signals_history[-1].timestamp if self.signals_history else None
            ),
        }

    def reset_positions(self):
        """Clear all position tracking (for backtesting or reset)."""
        self.positions = {}
        logger.info(f"{self.name}: Reset all positions")

    def set_active(self, active: bool):
        """Enable or disable the strategy."""
        self.is_active = active
        logger.info(f"{self.name}: Set active status to {active}")

    def update_config(self, **new_config):
        """Update strategy configuration."""
        self.config.update(new_config)
        logger.info(f"{self.name}: Updated configuration with {new_config}")

    def __str__(self):
        return f"{self.name}(symbols={self.symbols}, positions={len(self.positions)})"

    def __repr__(self):
        return self.__str__()
