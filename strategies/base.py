"""
Base strategy classes for the algorithmic trading system.
Provides abstract interfaces and common functionality for all trading strategies.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
from typing import Dict, List, Optional, Union, Any, Tuple
import pandas as pd
import logging
from datetime import datetime
import numpy as np

# Set up logging
logger = logging.getLogger(__name__)


class SignalType(Enum):
    """Types of trading signals."""

    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"
    CLOSE_LONG = "CLOSE_LONG"
    CLOSE_SHORT = "CLOSE_SHORT"


class PositionAction(Enum):
    """Types of position actions based on current vs target positions."""

    OPEN_NEW = "OPEN_NEW"  # No current position, should open new
    INCREASE = "INCREASE"  # Current position exists, should increase
    DECREASE = "DECREASE"  # Current position exists, should decrease
    MAINTAIN = "MAINTAIN"  # Current position matches target, no action
    CLOSE = "CLOSE"  # Should close existing position


@dataclass
class StrategySignal:
    """
    Represents a trading signal generated by a strategy.
    """

    symbol: str
    signal_type: SignalType
    confidence: float  # 0.0 to 1.0
    price: Optional[float] = None
    quantity: Optional[int] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    timestamp: datetime = None
    strategy_name: str = ""
    metadata: Dict[str, Any] = None
    position_action: Optional[PositionAction] = (
        None  # New field for position-aware actions
    )

    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now()
        if self.metadata is None:
            self.metadata = {}


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    Provides common interface and functionality for strategy implementation.
    """

    def __init__(self, name: str, symbols: List[str], alpaca_client=None, **config):
        """
        Initialize the strategy.

        Args:
            name: Strategy name
            symbols: List of symbols to trade
            alpaca_client: Optional AlpacaTradingClient for position synchronization
            **config: Strategy-specific configuration parameters
        """
        self.name = name
        self.symbols = symbols
        self.alpaca_client = alpaca_client  # For broker position synchronization
        self.config = config
        self.positions = {}  # Track current positions (synced with broker)
        self.signals_history = []  # Track signal history
        self.performance_metrics = {}
        self.is_active = True
        self.last_position_sync = None  # Track when positions were last synced

        # Default configuration
        self.default_config = {
            "max_position_size": 0.20,  # 20% of portfolio max per position
            "stop_loss_pct": 0.10,  # 10% stop loss
            "take_profit_pct": 0.20,  # 20% take profit
            "min_confidence": 0.7,  # Minimum signal confidence to trade
            "max_positions": 5,  # Maximum concurrent positions
            "risk_per_trade": 0.02,  # 2% portfolio risk per trade
            "position_sync_frequency": 300,  # Sync positions every 5 minutes
            "min_position_change_pct": 0.05,  # 5% minimum change to trigger action
        }

        # Merge with provided config
        self.config = {**self.default_config, **self.config}

        logger.info(f"Initialized {self.name} strategy for symbols: {self.symbols}")

    def sync_with_broker_positions(self, force_sync: bool = False) -> bool:
        """
        Synchronize strategy positions with actual broker positions.

        Args:
            force_sync: Force sync even if within frequency limit

        Returns:
            True if sync was successful, False otherwise
        """
        if not self.alpaca_client:
            logger.warning(f"{self.name}: No Alpaca client available for position sync")
            return False

        # Check if we need to sync (frequency control)
        if not force_sync and self.last_position_sync:
            time_since_sync = (datetime.now() - self.last_position_sync).total_seconds()
            if time_since_sync < self.config["position_sync_frequency"]:
                return True  # Skip sync, positions are recent enough

        try:
            # Get real broker positions
            broker_positions = self.alpaca_client.get_positions()

            # Convert to strategy position format
            synced_positions = {}
            for pos in broker_positions:
                synced_positions[pos["symbol"]] = {
                    "quantity": pos["quantity"],
                    "entry_price": pos["avg_price"],
                    "current_price": pos["current_price"],
                    "market_value": pos["market_value"],
                    "unrealized_pnl": pos["unrealized_pnl"],
                    "entry_date": datetime.now(),  # We don't have exact entry date from broker
                    "stop_loss": None,  # Would need to be tracked separately
                    "take_profit": None,  # Would need to be tracked separately
                    "strategy_signal": None,  # Would need to be tracked separately
                }

            # Update strategy positions
            old_position_count = len(self.positions)
            self.positions = synced_positions
            self.last_position_sync = datetime.now()

            new_position_count = len(self.positions)
            logger.info(
                f"{self.name}: Synced {new_position_count} positions from broker "
                f"(was {old_position_count})"
            )

            return True

        except Exception as e:
            logger.error(f"{self.name}: Error syncing with broker positions: {str(e)}")
            return False

    def determine_position_action(
        self, symbol: str, target_quantity: int, current_price: float
    ) -> Tuple[PositionAction, int]:
        """
        Determine what action to take based on current vs target position.

        Args:
            symbol: Asset symbol
            target_quantity: Target quantity to hold
            current_price: Current price of the asset

        Returns:
            Tuple of (PositionAction, quantity_to_trade)
        """
        current_quantity = self.positions.get(symbol, {}).get("quantity", 0)

        if current_quantity == 0 and target_quantity > 0:
            return PositionAction.OPEN_NEW, target_quantity
        elif current_quantity > 0 and target_quantity == 0:
            return PositionAction.CLOSE, current_quantity
        elif current_quantity > 0 and target_quantity > 0:
            # Calculate percentage change
            if current_quantity > 0:
                change_pct = abs(target_quantity - current_quantity) / current_quantity
            else:
                change_pct = 1.0  # Any change from 0 is 100%

            # Check if change is significant enough
            if change_pct < self.config["min_position_change_pct"]:
                return PositionAction.MAINTAIN, 0
            elif target_quantity > current_quantity:
                return PositionAction.INCREASE, target_quantity - current_quantity
            else:
                return PositionAction.DECREASE, current_quantity - target_quantity
        else:
            return PositionAction.MAINTAIN, 0

    def calculate_position_delta(
        self,
        symbol: str,
        target_allocation: float,
        portfolio_value: float,
        current_price: float,
    ) -> Tuple[int, PositionAction]:
        """
        Calculate the difference between current and target position sizes.

        Args:
            symbol: Asset symbol
            target_allocation: Target allocation as percentage of portfolio
            portfolio_value: Current portfolio value
            current_price: Current price of the asset

        Returns:
            Tuple of (quantity_delta, position_action)
        """
        current_quantity = self.positions.get(symbol, {}).get("quantity", 0)
        target_value = portfolio_value * target_allocation
        target_quantity = int(target_value / current_price) if current_price > 0 else 0

        action, quantity_to_trade = self.determine_position_action(
            symbol, target_quantity, current_price
        )

        return quantity_to_trade, action

    @abstractmethod
    def generate_signals(
        self, market_data: Dict[str, pd.DataFrame]
    ) -> List[StrategySignal]:
        """
        Generate trading signals based on market data.

        Args:
            market_data: Dictionary mapping symbol -> OHLCV DataFrame

        Returns:
            List of StrategySignal objects
        """
        pass

    @abstractmethod
    def should_enter_position(
        self, symbol: str, data: pd.DataFrame
    ) -> Optional[StrategySignal]:
        """
        Determine if strategy should enter a position for given symbol.

        Args:
            symbol: Stock/asset symbol
            data: OHLCV data for the symbol

        Returns:
            StrategySignal if should enter, None otherwise
        """
        pass

    @abstractmethod
    def should_exit_position(
        self, symbol: str, data: pd.DataFrame
    ) -> Optional[StrategySignal]:
        """
        Determine if strategy should exit existing position for given symbol.

        Args:
            symbol: Stock/asset symbol
            data: OHLCV data for the symbol

        Returns:
            StrategySignal if should exit, None otherwise
        """
        pass

    def validate_signal(self, signal: StrategySignal) -> bool:
        """
        Validate a trading signal against strategy rules.
        Now considers both internal and broker positions.

        Args:
            signal: The signal to validate

        Returns:
            True if signal is valid, False otherwise
        """
        # Sync positions if we have an Alpaca client
        if self.alpaca_client:
            self.sync_with_broker_positions()

        # Check confidence threshold
        if signal.confidence < self.config["min_confidence"]:
            logger.debug(
                f"Signal rejected: confidence {signal.confidence} below minimum {self.config['min_confidence']}"
            )
            return False

        # Check maximum positions limit
        if (
            signal.signal_type in [SignalType.BUY]
            and len(self.positions) >= self.config["max_positions"]
            and signal.symbol not in self.positions
        ):
            logger.debug(
                f"Signal rejected: maximum positions limit {self.config['max_positions']} reached"
            )
            return False

        # Check if we already have a position in this symbol (for new positions only)
        if signal.symbol in self.positions and signal.signal_type == SignalType.BUY:
            # Check if this is a position increase vs new position
            if (
                not signal.position_action
                or signal.position_action == PositionAction.OPEN_NEW
            ):
                logger.debug(
                    f"Signal rejected: already have position in {signal.symbol}"
                )
                return False

        return True

    def calculate_position_size(
        self, signal: StrategySignal, portfolio_value: float, current_price: float
    ) -> int:
        """
        Calculate appropriate position size based on risk management rules.
        Now accounts for existing positions.

        Args:
            signal: The trading signal
            portfolio_value: Current total portfolio value
            current_price: Current price of the asset

        Returns:
            Number of shares to trade
        """
        # Get current position if it exists
        current_quantity = self.positions.get(signal.symbol, {}).get("quantity", 0)

        # Calculate maximum position value based on portfolio percentage
        max_position_value = portfolio_value * self.config["max_position_size"]
        max_shares = int(max_position_value / current_price) if current_price > 0 else 0

        # Calculate position size based on risk per trade
        risk_amount = portfolio_value * self.config["risk_per_trade"]

        # If we have stop loss, size based on stop loss distance
        if signal.stop_loss:
            stop_distance = abs(current_price - signal.stop_loss)
            risk_based_shares = int(risk_amount / stop_distance)
            shares = min(risk_based_shares, max_shares)
        else:
            # Default to max position size
            shares = max_shares

        # Ensure we don't exceed maximum position size
        total_shares_after_trade = current_quantity + shares
        if total_shares_after_trade > max_shares:
            shares = max(0, max_shares - current_quantity)

        return max(1, shares)  # At least 1 share

    def update_position(
        self, symbol: str, signal: StrategySignal, executed_price: float, quantity: int
    ):
        """
        Update position tracking after signal execution.

        Args:
            symbol: Asset symbol
            signal: The executed signal
            executed_price: Price at which order was executed
            quantity: Quantity actually executed
        """
        if signal.signal_type == SignalType.BUY:
            self.positions[symbol] = {
                "quantity": quantity,
                "entry_price": executed_price,
                "entry_date": signal.timestamp,
                "stop_loss": signal.stop_loss,
                "take_profit": signal.take_profit,
                "strategy_signal": signal,
            }
            logger.info(
                f"Opened position: {symbol} x{quantity} @ ${executed_price:.2f}"
            )

        elif signal.signal_type in [SignalType.SELL, SignalType.CLOSE_LONG]:
            if symbol in self.positions:
                position = self.positions[symbol]
                profit_loss = (executed_price - position["entry_price"]) * quantity
                logger.info(
                    f"Closed position: {symbol} x{quantity} @ ${executed_price:.2f}, P&L: ${profit_loss:.2f}"
                )
                del self.positions[symbol]

    def get_current_positions(self) -> Dict[str, Any]:
        """Get current positions dictionary."""
        return self.positions.copy()

    def get_signals_history(self) -> List[StrategySignal]:
        """Get history of all generated signals."""
        return self.signals_history.copy()

    def add_signal_to_history(self, signal: StrategySignal):
        """Add a signal to the history."""
        self.signals_history.append(signal)

    def _normalize_dataframe_columns(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Normalize DataFrame column names to lowercase for consistency.
        
        Args:
            df: DataFrame with potentially mixed case column names
            
        Returns:
            DataFrame with normalized lowercase column names
        """
        # Create a mapping for common column name variations
        column_mapping = {
            'Open': 'open',
            'High': 'high', 
            'Low': 'low',
            'Close': 'close',
            'Volume': 'volume',
            'Adj Close': 'adj_close',
            'Adj_Close': 'adj_close',
            'adj_close': 'adj_close',  # Already correct
            'open': 'open',  # Already correct
            'high': 'high',  # Already correct
            'low': 'low',  # Already correct
            'close': 'close',  # Already correct
            'volume': 'volume',  # Already correct
        }
        
        # Rename columns that need normalization
        rename_dict = {}
        for col in df.columns:
            if col in column_mapping and col != column_mapping[col]:
                rename_dict[col] = column_mapping[col]
        
        if rename_dict:
            df = df.rename(columns=rename_dict)
            logger.debug(f"Normalized column names: {rename_dict}")
            
        return df

    def _get_close_price(self, data: pd.DataFrame) -> pd.Series:
        """
        Safely get close price series with fallback column names.
        
        Args:
            data: DataFrame with OHLCV data
            
        Returns:
            Series with close prices
            
        Raises:
            KeyError: If no close price column can be found
        """
        # Normalize column names first
        data = self._normalize_dataframe_columns(data)
        
        # Try different possible column names for close price
        close_columns = ['close', 'Close', 'CLOSE']
        for col in close_columns:
            if col in data.columns:
                return data[col]
        
        # If no close column found, raise error with helpful message
        available_columns = list(data.columns)
        raise KeyError(
            f"No close price column found. Available columns: {available_columns}. "
            f"Expected one of: {close_columns}"
        )

    def _validate_market_data(self, market_data: Dict[str, pd.DataFrame]) -> Dict[str, pd.DataFrame]:
        """
        Validate and normalize market data column names.
        
        Args:
            market_data: Dictionary mapping symbol -> OHLCV DataFrame
            
        Returns:
            Dictionary with normalized DataFrames
        """
        validated_data = {}
        
        for symbol, df in market_data.items():
            if df is None or df.empty:
                logger.warning(f"Skipping {symbol}: DataFrame is None or empty")
                continue
                
            try:
                # Normalize column names
                normalized_df = self._normalize_dataframe_columns(df)
                
                # Validate required columns exist
                required_cols = ['open', 'high', 'low', 'close', 'volume']
                missing_cols = [col for col in required_cols if col not in normalized_df.columns]
                
                if missing_cols:
                    logger.warning(f"Skipping {symbol}: Missing columns {missing_cols}")
                    continue
                    
                validated_data[symbol] = normalized_df
                
            except Exception as e:
                logger.error(f"Error validating data for {symbol}: {e}")
                continue
                
        return validated_data

    def get_performance_summary(self) -> Dict[str, Any]:
        """
        Get basic performance metrics for the strategy.

        Returns:
            Dictionary with performance metrics
        """
        total_signals = len(self.signals_history)
        buy_signals = len(
            [s for s in self.signals_history if s.signal_type == SignalType.BUY]
        )
        sell_signals = len(
            [
                s
                for s in self.signals_history
                if s.signal_type in [SignalType.SELL, SignalType.CLOSE_LONG]
            ]
        )

        return {
            "strategy_name": self.name,
            "total_signals": total_signals,
            "buy_signals": buy_signals,
            "sell_signals": sell_signals,
            "current_positions": len(self.positions),
            "active_symbols": self.symbols,
            "is_active": self.is_active,
            "last_signal_time": (
                self.signals_history[-1].timestamp if self.signals_history else None
            ),
        }

    def reset_positions(self):
        """Clear all position tracking (for backtesting or reset)."""
        self.positions = {}
        logger.info(f"{self.name}: Reset all positions")

    def set_active(self, active: bool):
        """Enable or disable the strategy."""
        self.is_active = active
        logger.info(f"{self.name}: Set active status to {active}")

    def update_config(self, **new_config):
        """Update strategy configuration."""
        self.config.update(new_config)
        logger.info(f"{self.name}: Updated configuration with {new_config}")

    def __str__(self):
        return f"{self.name}(symbols={self.symbols}, positions={len(self.positions)})"

    def __repr__(self):
        return self.__str__()
